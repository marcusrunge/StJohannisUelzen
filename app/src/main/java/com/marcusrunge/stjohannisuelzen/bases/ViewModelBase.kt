package com.marcusrunge.stjohannisuelzen.bases

import android.os.Handler
import android.os.Looper
import android.os.Message
import androidx.databinding.Observable
import androidx.databinding.PropertyChangeRegistry
import androidx.lifecycle.ViewModel

/**
 * A base class for [ViewModel]s that implements the [Observable] interface from the Data Binding Library.
 *
 * This abstract class provides the foundational support for notifying the UI of property changes,
 * a core requirement for data binding. It includes a [PropertyChangeRegistry] to manage listeners
 * and helper methods to trigger notifications.
 *
 * It also features a [Handler] to facilitate message passing from background threads to the main
 * thread, allowing for safe UI updates.
 *
 * @see ViewModel
 * @see Observable
 */
abstract class ViewModelBase : ViewModel(), Observable {

    companion object {
        /**
         * A constant message identifier for the [handler].
         *
         * This can be used in messages sent to the handler to specify that a general
         * view update is required.
         */
        const val UPDATE_VIEW: Int = 1
    }

    @Transient
    private val propertyChangeRegistry = PropertyChangeRegistry()

    /**
     * A [Handler] for processing messages on the main thread.
     *
     * Subclasses can use this handler to post messages from background threads. The handler
     * will then process these messages on the main looper, making it safe to interact with
     * the UI. It currently handles the [UPDATE_VIEW] message by delegating to the
     * [updateView] method.
     */
    protected val handler: Handler = object : Handler(Looper.getMainLooper()) {
        override fun handleMessage(inputMessage: Message) {
            when (inputMessage.what) {
                UPDATE_VIEW -> updateView(inputMessage)
            }
        }
    }

    /**
     * An abstract method that must be implemented by subclasses to handle view updates.
     *
     * This method is called on the main thread when the [handler] receives a message with
     * the `what` field set to [UPDATE_VIEW].
     *
     * @param inputMessage The [Message] object received by the handler. Subclasses can use
     *                     its `obj`, `arg1`, `arg2`, etc., fields to pass data.
     */
    abstract fun updateView(inputMessage: Message)

    /**
     * Adds a callback to listen for property changes.
     *
     * This is part of the [Observable] interface implementation.
     *
     * @param callback The callback to add.
     */
    override fun addOnPropertyChangedCallback(callback: Observable.OnPropertyChangedCallback) {
        propertyChangeRegistry.add(callback)
    }

    /**
     * Removes a callback that was previously added to listen for property changes.
     *
     * This is part of the [Observable] interface implementation.
     *
     * @param callback The callback to remove.
     */
    override fun removeOnPropertyChangedCallback(callback: Observable.OnPropertyChangedCallback) {
        propertyChangeRegistry.remove(callback)
    }

    /**
     * Notifies all registered listeners that all properties of this object have changed.
     *
     * This method is thread-safe.
     */
    protected fun notifyPropertiesChanged() {
        synchronized(this) {
            propertyChangeRegistry.notifyCallbacks(this, 0, null)
        }
    }

    /**
     * Notifies all registered listeners that a specific property has changed.
     *
     * The property change is identified by a field ID generated by the data binding compiler.
     *
     * This method is thread-safe.
     *
     * @param propertyId The BR ID of the property that has changed.
     */
    protected fun notifyPropertyChanged(propertyId: Int) {
        synchronized(this) {
            propertyChangeRegistry.notifyCallbacks(this, propertyId, null)
        }
    }
}
